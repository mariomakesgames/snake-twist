<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Segment Drop 复活修复测试</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }
        .container {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            padding: 30px;
            backdrop-filter: blur(10px);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        }
        .test-section {
            margin: 20px 0;
            padding: 20px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
            border-left: 4px solid #4CAF50;
        }
        .log {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 15px;
            margin: 10px 0;
            max-height: 300px;
            overflow-y: auto;
            font-family: 'Courier New', monospace;
            font-size: 14px;
        }
        .log-entry {
            margin: 5px 0;
            padding: 5px;
            border-radius: 4px;
        }
        .log-info { background: rgba(76, 175, 80, 0.2); }
        .log-success { background: rgba(76, 175, 80, 0.3); color: #4CAF50; }
        .log-warn { background: rgba(255, 193, 7, 0.3); color: #FFC107; }
        .log-error { background: rgba(244, 67, 54, 0.3); color: #F44336; }
        .button {
            background: linear-gradient(45deg, #4CAF50, #45A049);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 25px;
            cursor: pointer;
            margin: 5px;
            font-size: 16px;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(76, 175, 80, 0.3);
        }
        .button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(76, 175, 80, 0.4);
        }
        .button:disabled {
            background: #666;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }
        .status {
            display: flex;
            justify-content: space-between;
            margin: 20px 0;
            flex-wrap: wrap;
        }
        .status-item {
            background: rgba(255, 255, 255, 0.1);
            padding: 10px 15px;
            border-radius: 8px;
            margin: 5px;
            text-align: center;
            min-width: 120px;
        }
        .status-value {
            font-size: 18px;
            font-weight: bold;
            color: #4CAF50;
        }
        h1 {
            text-align: center;
            color: #4CAF50;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
        }
        h2 {
            color: #4CAF50;
            border-bottom: 2px solid #4CAF50;
            padding-bottom: 10px;
        }
        .visualization {
            background: rgba(0, 0, 0, 0.2);
            border-radius: 8px;
            padding: 15px;
            margin: 10px 0;
            font-family: monospace;
            white-space: pre;
            font-size: 12px;
            max-height: 200px;
            overflow-y: auto;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>🟩 Segment Drop 复活修复测试</h1>
        
        <div class="test-section">
            <h2>🎯 修复内容</h2>
            <ul>
                <li><strong>问题1</strong>: 复活后掉落的segment不见了</li>
                <li><strong>原因1</strong>: 重新创建的segment drops没有正确设置碰撞检测</li>
                <li><strong>问题2</strong>: segment掉落时落在obstacle上</li>
                <li><strong>原因2</strong>: segment drops生成时没有检查障碍物碰撞</li>
                <li><strong>修复</strong>: 
                    <ul>
                        <li>添加障碍物碰撞检测到segment drops生成</li>
                        <li>修复复活时segment drops的碰撞检测设置</li>
                        <li>确保segment drops不会落在障碍物上</li>
                    </ul>
                </li>
            </ul>
        </div>

        <div class="status">
            <div class="status-item">
                <div>游戏状态</div>
                <div class="status-value" id="gameState">未开始</div>
            </div>
            <div class="status-item">
                <div>障碍物数量</div>
                <div class="status-value" id="obstacleCount">0</div>
            </div>
            <div class="status-item">
                <div>Segment Drops</div>
                <div class="status-value" id="segmentDropCount">0</div>
            </div>
            <div class="status-item">
                <div>复活状态</div>
                <div class="status-value" id="revivalState">否</div>
            </div>
        </div>

        <div class="test-section">
            <h2>🧪 测试操作</h2>
            <button class="button" onclick="startNewGame()">🎮 开始新游戏</button>
            <button class="button" onclick="simulateGameOver()">💀 模拟游戏结束</button>
            <button class="button" onclick="simulateRevival()">🔄 模拟复活</button>
            <button class="button" onclick="checkSegmentDrops()">🔍 检查Segment Drops</button>
            <button class="button" onclick="clearLog()">🗑️ 清空日志</button>
        </div>

        <div class="test-section">
            <h2>🎨 地图可视化</h2>
            <div class="visualization" id="mapVisualization">
                地图将在这里显示...
            </div>
        </div>

        <div class="test-section">
            <h2>📊 测试日志</h2>
            <div class="log" id="log"></div>
        </div>
    </div>

    <script>
        // 模拟游戏状态
        const gameState = {
            isGameOver: false,
            isReviving: false,
            score: 0,
            savedObstaclePositions: null,
            savedSegmentDropsData: null
        };

        // 模拟障碍物和segment drops数据
        let currentObstacles = [];
        let currentSegmentDrops = [];
        const mapWidth = 30; // 30格宽
        const mapHeight = 40; // 40格高

        function log(message, type = 'info') {
            const logDiv = document.getElementById('log');
            const entry = document.createElement('div');
            entry.className = `log-entry log-${type}`;
            entry.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
            logDiv.appendChild(entry);
            logDiv.scrollTop = logDiv.scrollHeight;
        }

        function updateStatus() {
            document.getElementById('gameState').textContent = 
                gameState.isGameOver ? '游戏结束' : 
                gameState.isReviving ? '复活中' : '进行中';
            
            document.getElementById('obstacleCount').textContent = 
                currentObstacles.length;
            
            document.getElementById('segmentDropCount').textContent = 
                currentSegmentDrops.length;
            
            document.getElementById('revivalState').textContent = 
                gameState.isReviving ? '是' : '否';
        }

        function updateMapVisualization() {
            const mapDiv = document.getElementById('mapVisualization');
            let map = '';
            
            for (let y = 0; y < mapHeight; y++) {
                let row = '';
                for (let x = 0; x < mapWidth; x++) {
                    const pixelX = x * 20 + 10;
                    const pixelY = y * 20 + 10;
                    
                    // 检查是否是障碍物
                    const isObstacle = currentObstacles.some(obs => 
                        Math.abs(obs.x - pixelX) < 15 && Math.abs(obs.y - pixelY) < 15
                    );
                    
                    // 检查是否是segment drop
                    const isSegmentDrop = currentSegmentDrops.some(drop => 
                        Math.abs(drop.x - pixelX) < 15 && Math.abs(drop.y - pixelY) < 15
                    );
                    
                    if (isObstacle) {
                        row += '█'; // 障碍物
                    } else if (isSegmentDrop) {
                        row += '🟩'; // Segment drop
                    } else {
                        row += '·'; // 空地
                    }
                }
                map += row + '\n';
            }
            
            mapDiv.textContent = map;
        }

        function isPositionOccupied(x, y) {
            return currentObstacles.some(obs => 
                Math.abs(obs.x - x) < 15 && Math.abs(obs.y - y) < 15
            );
        }

        function findValidSegmentDropPosition(centerX, centerY) {
            const gridSize = 20;
            
            // 尝试中心位置
            if (!isPositionOccupied(centerX, centerY)) {
                return { x: centerX, y: centerY };
            }
            
            // 螺旋搜索
            const maxAttempts = 50;
            let attempts = 0;
            let radius = 1;
            
            while (attempts < maxAttempts) {
                for (let dx = -radius; dx <= radius; dx++) {
                    for (let dy = -radius; dy <= radius; dy++) {
                        if (Math.abs(dx) === radius || Math.abs(dy) === radius) {
                            const testX = centerX + dx * gridSize;
                            const testY = centerY + dy * gridSize;
                            
                            if (testX >= 10 && testX < 590 && testY >= 10 && testY < 790) {
                                if (!isPositionOccupied(testX, testY)) {
                                    return { x: testX, y: testY };
                                }
                            }
                            attempts++;
                        }
                    }
                }
                radius++;
            }
            
            return { x: centerX, y: centerY };
        }

        function startNewGame() {
            log('🎮 开始新游戏...', 'info');
            
            // 重置游戏状态
            gameState.score = 0;
            gameState.isGameOver = false;
            gameState.isReviving = false;
            gameState.savedObstaclePositions = null;
            gameState.savedSegmentDropsData = null;
            
            // 模拟生成障碍物
            currentObstacles = [];
            const obstacleCount = Math.floor(Math.random() * 10) + 5;
            
            for (let i = 0; i < obstacleCount; i++) {
                const x = Math.floor(Math.random() * 600);
                const y = Math.floor(Math.random() * 800);
                currentObstacles.push({ x, y });
            }
            
            // 清空segment drops
            currentSegmentDrops = [];
            
            log(`🧱 生成了 ${currentObstacles.length} 个障碍物`, 'success');
            log(`📍 障碍物位置: ${JSON.stringify(currentObstacles.slice(0, 3))}...`, 'info');
            
            updateStatus();
            updateMapVisualization();
        }

        function simulateGameOver() {
            if (gameState.isGameOver) {
                log('⚠️ 游戏已经结束', 'warn');
                return;
            }
            
            log('💀 模拟游戏结束...', 'info');
            
            gameState.isGameOver = true;
            
            // 模拟生成segment drops
            const deathX = 300; // 模拟死亡位置
            const deathY = 400;
            const dropCount = Math.floor(Math.random() * 3) + 2; // 2-4个drops
            
            currentSegmentDrops = [];
            
            for (let i = 0; i < dropCount; i++) {
                const angle = (i / dropCount) * Math.PI * 2;
                const distance = 60 + Math.random() * 40;
                const rawX = deathX + Math.cos(angle) * distance;
                const rawY = deathY + Math.sin(angle) * distance;
                
                // 对齐到网格
                const gridX = Math.floor(rawX / 20) * 20 + 10;
                const gridY = Math.floor(rawY / 20) * 20 + 10;
                
                // 确保在边界内
                const clampedX = Math.max(10, Math.min(590, gridX));
                const clampedY = Math.max(10, Math.min(790, gridY));
                
                // 找到不与障碍物重叠的位置
                const validPosition = findValidSegmentDropPosition(clampedX, clampedY);
                
                currentSegmentDrops.push({
                    x: validPosition.x,
                    y: validPosition.y,
                    value: 1
                });
            }
            
            // 保存数据
            gameState.savedObstaclePositions = [...currentObstacles];
            gameState.savedSegmentDropsData = [...currentSegmentDrops];
            
            log(`💾 保存了 ${currentSegmentDrops.length} 个segment drops`, 'success');
            log(`📍 Segment drops位置: ${JSON.stringify(currentSegmentDrops)}`, 'info');
            
            updateStatus();
            updateMapVisualization();
        }

        function simulateRevival() {
            if (!gameState.isGameOver) {
                log('⚠️ 游戏尚未结束，无法复活', 'warn');
                return;
            }
            
            if (!gameState.savedSegmentDropsData) {
                log('⚠️ 没有保存的segment drops数据', 'warn');
                return;
            }
            
            log('🔄 模拟复活...', 'info');
            
            gameState.isReviving = true;
            gameState.isGameOver = false;
            
            // 恢复障碍物
            currentObstacles = [...gameState.savedObstaclePositions];
            
            // 恢复segment drops
            currentSegmentDrops = [...gameState.savedSegmentDropsData];
            
            log(`🟩 恢复了 ${currentSegmentDrops.length} 个segment drops`, 'success');
            log(`📍 恢复的segment drops: ${JSON.stringify(currentSegmentDrops)}`, 'info');
            
            // 验证segment drops是否与障碍物重叠
            const overlappingDrops = currentSegmentDrops.filter(drop => 
                isPositionOccupied(drop.x, drop.y)
            );
            
            if (overlappingDrops.length > 0) {
                log(`❌ 发现 ${overlappingDrops.length} 个segment drops与障碍物重叠！`, 'error');
            } else {
                log('✅ 所有segment drops都没有与障碍物重叠！', 'success');
            }
            
            // 清除保存的数据
            gameState.savedObstaclePositions = null;
            gameState.savedSegmentDropsData = null;
            gameState.isReviving = false;
            
            updateStatus();
            updateMapVisualization();
        }

        function checkSegmentDrops() {
            log('🔍 检查Segment Drops状态...', 'info');
            
            if (gameState.savedSegmentDropsData) {
                log(`📊 当前保存的segment drops: ${gameState.savedSegmentDropsData.length}个`, 'info');
                log(`📍 保存的位置: ${JSON.stringify(gameState.savedSegmentDropsData)}`, 'info');
            } else {
                log('📊 当前没有保存的segment drops', 'warn');
            }
            
            if (currentSegmentDrops.length > 0) {
                log(`📊 当前segment drops: ${currentSegmentDrops.length}个`, 'info');
                log(`📍 当前位置: ${JSON.stringify(currentSegmentDrops)}`, 'info');
                
                // 检查重叠
                const overlappingDrops = currentSegmentDrops.filter(drop => 
                    isPositionOccupied(drop.x, drop.y)
                );
                
                if (overlappingDrops.length > 0) {
                    log(`⚠️ 发现 ${overlappingDrops.length} 个segment drops与障碍物重叠`, 'warn');
                } else {
                    log('✅ 所有segment drops都没有与障碍物重叠', 'success');
                }
            } else {
                log('📊 当前没有segment drops', 'warn');
            }
            
            if (gameState.isReviving) {
                log('🔄 当前处于复活状态', 'info');
            }
            
            if (gameState.isGameOver) {
                log('💀 当前处于游戏结束状态', 'info');
            }
        }

        function clearLog() {
            document.getElementById('log').innerHTML = '';
            log('🗑️ 日志已清空', 'info');
        }

        // 初始化
        updateStatus();
        updateMapVisualization();
        log('🎯 Segment Drop复活修复测试环境已准备就绪', 'success');
        log('📝 测试步骤：', 'info');
        log('1. 点击"开始新游戏"生成障碍物', 'info');
        log('2. 点击"模拟游戏结束"生成segment drops', 'info');
        log('3. 点击"模拟复活"恢复segment drops', 'info');
        log('4. 验证segment drops是否与障碍物重叠', 'info');
        log('5. 检查复活后segment drops是否可见', 'info');
    </script>
</body>
</html> 
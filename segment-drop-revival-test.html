<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Segment Drop å¤æ´»ä¿®å¤æµ‹è¯•</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }
        .container {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            padding: 30px;
            backdrop-filter: blur(10px);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        }
        .test-section {
            margin: 20px 0;
            padding: 20px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
            border-left: 4px solid #4CAF50;
        }
        .log {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 15px;
            margin: 10px 0;
            max-height: 300px;
            overflow-y: auto;
            font-family: 'Courier New', monospace;
            font-size: 14px;
        }
        .log-entry {
            margin: 5px 0;
            padding: 5px;
            border-radius: 4px;
        }
        .log-info { background: rgba(76, 175, 80, 0.2); }
        .log-success { background: rgba(76, 175, 80, 0.3); color: #4CAF50; }
        .log-warn { background: rgba(255, 193, 7, 0.3); color: #FFC107; }
        .log-error { background: rgba(244, 67, 54, 0.3); color: #F44336; }
        .button {
            background: linear-gradient(45deg, #4CAF50, #45A049);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 25px;
            cursor: pointer;
            margin: 5px;
            font-size: 16px;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(76, 175, 80, 0.3);
        }
        .button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(76, 175, 80, 0.4);
        }
        .button:disabled {
            background: #666;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }
        .status {
            display: flex;
            justify-content: space-between;
            margin: 20px 0;
            flex-wrap: wrap;
        }
        .status-item {
            background: rgba(255, 255, 255, 0.1);
            padding: 10px 15px;
            border-radius: 8px;
            margin: 5px;
            text-align: center;
            min-width: 120px;
        }
        .status-value {
            font-size: 18px;
            font-weight: bold;
            color: #4CAF50;
        }
        h1 {
            text-align: center;
            color: #4CAF50;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
        }
        h2 {
            color: #4CAF50;
            border-bottom: 2px solid #4CAF50;
            padding-bottom: 10px;
        }
        .visualization {
            background: rgba(0, 0, 0, 0.2);
            border-radius: 8px;
            padding: 15px;
            margin: 10px 0;
            font-family: monospace;
            white-space: pre;
            font-size: 12px;
            max-height: 200px;
            overflow-y: auto;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ğŸŸ© Segment Drop å¤æ´»ä¿®å¤æµ‹è¯•</h1>
        
        <div class="test-section">
            <h2>ğŸ¯ ä¿®å¤å†…å®¹</h2>
            <ul>
                <li><strong>é—®é¢˜1</strong>: å¤æ´»åæ‰è½çš„segmentä¸è§äº†</li>
                <li><strong>åŸå› 1</strong>: é‡æ–°åˆ›å»ºçš„segment dropsæ²¡æœ‰æ­£ç¡®è®¾ç½®ç¢°æ’æ£€æµ‹</li>
                <li><strong>é—®é¢˜2</strong>: segmentæ‰è½æ—¶è½åœ¨obstacleä¸Š</li>
                <li><strong>åŸå› 2</strong>: segment dropsç”Ÿæˆæ—¶æ²¡æœ‰æ£€æŸ¥éšœç¢ç‰©ç¢°æ’</li>
                <li><strong>ä¿®å¤</strong>: 
                    <ul>
                        <li>æ·»åŠ éšœç¢ç‰©ç¢°æ’æ£€æµ‹åˆ°segment dropsç”Ÿæˆ</li>
                        <li>ä¿®å¤å¤æ´»æ—¶segment dropsçš„ç¢°æ’æ£€æµ‹è®¾ç½®</li>
                        <li>ç¡®ä¿segment dropsä¸ä¼šè½åœ¨éšœç¢ç‰©ä¸Š</li>
                    </ul>
                </li>
            </ul>
        </div>

        <div class="status">
            <div class="status-item">
                <div>æ¸¸æˆçŠ¶æ€</div>
                <div class="status-value" id="gameState">æœªå¼€å§‹</div>
            </div>
            <div class="status-item">
                <div>éšœç¢ç‰©æ•°é‡</div>
                <div class="status-value" id="obstacleCount">0</div>
            </div>
            <div class="status-item">
                <div>Segment Drops</div>
                <div class="status-value" id="segmentDropCount">0</div>
            </div>
            <div class="status-item">
                <div>å¤æ´»çŠ¶æ€</div>
                <div class="status-value" id="revivalState">å¦</div>
            </div>
        </div>

        <div class="test-section">
            <h2>ğŸ§ª æµ‹è¯•æ“ä½œ</h2>
            <button class="button" onclick="startNewGame()">ğŸ® å¼€å§‹æ–°æ¸¸æˆ</button>
            <button class="button" onclick="simulateGameOver()">ğŸ’€ æ¨¡æ‹Ÿæ¸¸æˆç»“æŸ</button>
            <button class="button" onclick="simulateRevival()">ğŸ”„ æ¨¡æ‹Ÿå¤æ´»</button>
            <button class="button" onclick="checkSegmentDrops()">ğŸ” æ£€æŸ¥Segment Drops</button>
            <button class="button" onclick="clearLog()">ğŸ—‘ï¸ æ¸…ç©ºæ—¥å¿—</button>
        </div>

        <div class="test-section">
            <h2>ğŸ¨ åœ°å›¾å¯è§†åŒ–</h2>
            <div class="visualization" id="mapVisualization">
                åœ°å›¾å°†åœ¨è¿™é‡Œæ˜¾ç¤º...
            </div>
        </div>

        <div class="test-section">
            <h2>ğŸ“Š æµ‹è¯•æ—¥å¿—</h2>
            <div class="log" id="log"></div>
        </div>
    </div>

    <script>
        // æ¨¡æ‹Ÿæ¸¸æˆçŠ¶æ€
        const gameState = {
            isGameOver: false,
            isReviving: false,
            score: 0,
            savedObstaclePositions: null,
            savedSegmentDropsData: null
        };

        // æ¨¡æ‹Ÿéšœç¢ç‰©å’Œsegment dropsæ•°æ®
        let currentObstacles = [];
        let currentSegmentDrops = [];
        const mapWidth = 30; // 30æ ¼å®½
        const mapHeight = 40; // 40æ ¼é«˜

        function log(message, type = 'info') {
            const logDiv = document.getElementById('log');
            const entry = document.createElement('div');
            entry.className = `log-entry log-${type}`;
            entry.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
            logDiv.appendChild(entry);
            logDiv.scrollTop = logDiv.scrollHeight;
        }

        function updateStatus() {
            document.getElementById('gameState').textContent = 
                gameState.isGameOver ? 'æ¸¸æˆç»“æŸ' : 
                gameState.isReviving ? 'å¤æ´»ä¸­' : 'è¿›è¡Œä¸­';
            
            document.getElementById('obstacleCount').textContent = 
                currentObstacles.length;
            
            document.getElementById('segmentDropCount').textContent = 
                currentSegmentDrops.length;
            
            document.getElementById('revivalState').textContent = 
                gameState.isReviving ? 'æ˜¯' : 'å¦';
        }

        function updateMapVisualization() {
            const mapDiv = document.getElementById('mapVisualization');
            let map = '';
            
            for (let y = 0; y < mapHeight; y++) {
                let row = '';
                for (let x = 0; x < mapWidth; x++) {
                    const pixelX = x * 20 + 10;
                    const pixelY = y * 20 + 10;
                    
                    // æ£€æŸ¥æ˜¯å¦æ˜¯éšœç¢ç‰©
                    const isObstacle = currentObstacles.some(obs => 
                        Math.abs(obs.x - pixelX) < 15 && Math.abs(obs.y - pixelY) < 15
                    );
                    
                    // æ£€æŸ¥æ˜¯å¦æ˜¯segment drop
                    const isSegmentDrop = currentSegmentDrops.some(drop => 
                        Math.abs(drop.x - pixelX) < 15 && Math.abs(drop.y - pixelY) < 15
                    );
                    
                    if (isObstacle) {
                        row += 'â–ˆ'; // éšœç¢ç‰©
                    } else if (isSegmentDrop) {
                        row += 'ğŸŸ©'; // Segment drop
                    } else {
                        row += 'Â·'; // ç©ºåœ°
                    }
                }
                map += row + '\n';
            }
            
            mapDiv.textContent = map;
        }

        function isPositionOccupied(x, y) {
            return currentObstacles.some(obs => 
                Math.abs(obs.x - x) < 15 && Math.abs(obs.y - y) < 15
            );
        }

        function findValidSegmentDropPosition(centerX, centerY) {
            const gridSize = 20;
            
            // å°è¯•ä¸­å¿ƒä½ç½®
            if (!isPositionOccupied(centerX, centerY)) {
                return { x: centerX, y: centerY };
            }
            
            // èºæ—‹æœç´¢
            const maxAttempts = 50;
            let attempts = 0;
            let radius = 1;
            
            while (attempts < maxAttempts) {
                for (let dx = -radius; dx <= radius; dx++) {
                    for (let dy = -radius; dy <= radius; dy++) {
                        if (Math.abs(dx) === radius || Math.abs(dy) === radius) {
                            const testX = centerX + dx * gridSize;
                            const testY = centerY + dy * gridSize;
                            
                            if (testX >= 10 && testX < 590 && testY >= 10 && testY < 790) {
                                if (!isPositionOccupied(testX, testY)) {
                                    return { x: testX, y: testY };
                                }
                            }
                            attempts++;
                        }
                    }
                }
                radius++;
            }
            
            return { x: centerX, y: centerY };
        }

        function startNewGame() {
            log('ğŸ® å¼€å§‹æ–°æ¸¸æˆ...', 'info');
            
            // é‡ç½®æ¸¸æˆçŠ¶æ€
            gameState.score = 0;
            gameState.isGameOver = false;
            gameState.isReviving = false;
            gameState.savedObstaclePositions = null;
            gameState.savedSegmentDropsData = null;
            
            // æ¨¡æ‹Ÿç”Ÿæˆéšœç¢ç‰©
            currentObstacles = [];
            const obstacleCount = Math.floor(Math.random() * 10) + 5;
            
            for (let i = 0; i < obstacleCount; i++) {
                const x = Math.floor(Math.random() * 600);
                const y = Math.floor(Math.random() * 800);
                currentObstacles.push({ x, y });
            }
            
            // æ¸…ç©ºsegment drops
            currentSegmentDrops = [];
            
            log(`ğŸ§± ç”Ÿæˆäº† ${currentObstacles.length} ä¸ªéšœç¢ç‰©`, 'success');
            log(`ğŸ“ éšœç¢ç‰©ä½ç½®: ${JSON.stringify(currentObstacles.slice(0, 3))}...`, 'info');
            
            updateStatus();
            updateMapVisualization();
        }

        function simulateGameOver() {
            if (gameState.isGameOver) {
                log('âš ï¸ æ¸¸æˆå·²ç»ç»“æŸ', 'warn');
                return;
            }
            
            log('ğŸ’€ æ¨¡æ‹Ÿæ¸¸æˆç»“æŸ...', 'info');
            
            gameState.isGameOver = true;
            
            // æ¨¡æ‹Ÿç”Ÿæˆsegment drops
            const deathX = 300; // æ¨¡æ‹Ÿæ­»äº¡ä½ç½®
            const deathY = 400;
            const dropCount = Math.floor(Math.random() * 3) + 2; // 2-4ä¸ªdrops
            
            currentSegmentDrops = [];
            
            for (let i = 0; i < dropCount; i++) {
                const angle = (i / dropCount) * Math.PI * 2;
                const distance = 60 + Math.random() * 40;
                const rawX = deathX + Math.cos(angle) * distance;
                const rawY = deathY + Math.sin(angle) * distance;
                
                // å¯¹é½åˆ°ç½‘æ ¼
                const gridX = Math.floor(rawX / 20) * 20 + 10;
                const gridY = Math.floor(rawY / 20) * 20 + 10;
                
                // ç¡®ä¿åœ¨è¾¹ç•Œå†…
                const clampedX = Math.max(10, Math.min(590, gridX));
                const clampedY = Math.max(10, Math.min(790, gridY));
                
                // æ‰¾åˆ°ä¸ä¸éšœç¢ç‰©é‡å çš„ä½ç½®
                const validPosition = findValidSegmentDropPosition(clampedX, clampedY);
                
                currentSegmentDrops.push({
                    x: validPosition.x,
                    y: validPosition.y,
                    value: 1
                });
            }
            
            // ä¿å­˜æ•°æ®
            gameState.savedObstaclePositions = [...currentObstacles];
            gameState.savedSegmentDropsData = [...currentSegmentDrops];
            
            log(`ğŸ’¾ ä¿å­˜äº† ${currentSegmentDrops.length} ä¸ªsegment drops`, 'success');
            log(`ğŸ“ Segment dropsä½ç½®: ${JSON.stringify(currentSegmentDrops)}`, 'info');
            
            updateStatus();
            updateMapVisualization();
        }

        function simulateRevival() {
            if (!gameState.isGameOver) {
                log('âš ï¸ æ¸¸æˆå°šæœªç»“æŸï¼Œæ— æ³•å¤æ´»', 'warn');
                return;
            }
            
            if (!gameState.savedSegmentDropsData) {
                log('âš ï¸ æ²¡æœ‰ä¿å­˜çš„segment dropsæ•°æ®', 'warn');
                return;
            }
            
            log('ğŸ”„ æ¨¡æ‹Ÿå¤æ´»...', 'info');
            
            gameState.isReviving = true;
            gameState.isGameOver = false;
            
            // æ¢å¤éšœç¢ç‰©
            currentObstacles = [...gameState.savedObstaclePositions];
            
            // æ¢å¤segment drops
            currentSegmentDrops = [...gameState.savedSegmentDropsData];
            
            log(`ğŸŸ© æ¢å¤äº† ${currentSegmentDrops.length} ä¸ªsegment drops`, 'success');
            log(`ğŸ“ æ¢å¤çš„segment drops: ${JSON.stringify(currentSegmentDrops)}`, 'info');
            
            // éªŒè¯segment dropsæ˜¯å¦ä¸éšœç¢ç‰©é‡å 
            const overlappingDrops = currentSegmentDrops.filter(drop => 
                isPositionOccupied(drop.x, drop.y)
            );
            
            if (overlappingDrops.length > 0) {
                log(`âŒ å‘ç° ${overlappingDrops.length} ä¸ªsegment dropsä¸éšœç¢ç‰©é‡å ï¼`, 'error');
            } else {
                log('âœ… æ‰€æœ‰segment dropséƒ½æ²¡æœ‰ä¸éšœç¢ç‰©é‡å ï¼', 'success');
            }
            
            // æ¸…é™¤ä¿å­˜çš„æ•°æ®
            gameState.savedObstaclePositions = null;
            gameState.savedSegmentDropsData = null;
            gameState.isReviving = false;
            
            updateStatus();
            updateMapVisualization();
        }

        function checkSegmentDrops() {
            log('ğŸ” æ£€æŸ¥Segment DropsçŠ¶æ€...', 'info');
            
            if (gameState.savedSegmentDropsData) {
                log(`ğŸ“Š å½“å‰ä¿å­˜çš„segment drops: ${gameState.savedSegmentDropsData.length}ä¸ª`, 'info');
                log(`ğŸ“ ä¿å­˜çš„ä½ç½®: ${JSON.stringify(gameState.savedSegmentDropsData)}`, 'info');
            } else {
                log('ğŸ“Š å½“å‰æ²¡æœ‰ä¿å­˜çš„segment drops', 'warn');
            }
            
            if (currentSegmentDrops.length > 0) {
                log(`ğŸ“Š å½“å‰segment drops: ${currentSegmentDrops.length}ä¸ª`, 'info');
                log(`ğŸ“ å½“å‰ä½ç½®: ${JSON.stringify(currentSegmentDrops)}`, 'info');
                
                // æ£€æŸ¥é‡å 
                const overlappingDrops = currentSegmentDrops.filter(drop => 
                    isPositionOccupied(drop.x, drop.y)
                );
                
                if (overlappingDrops.length > 0) {
                    log(`âš ï¸ å‘ç° ${overlappingDrops.length} ä¸ªsegment dropsä¸éšœç¢ç‰©é‡å `, 'warn');
                } else {
                    log('âœ… æ‰€æœ‰segment dropséƒ½æ²¡æœ‰ä¸éšœç¢ç‰©é‡å ', 'success');
                }
            } else {
                log('ğŸ“Š å½“å‰æ²¡æœ‰segment drops', 'warn');
            }
            
            if (gameState.isReviving) {
                log('ğŸ”„ å½“å‰å¤„äºå¤æ´»çŠ¶æ€', 'info');
            }
            
            if (gameState.isGameOver) {
                log('ğŸ’€ å½“å‰å¤„äºæ¸¸æˆç»“æŸçŠ¶æ€', 'info');
            }
        }

        function clearLog() {
            document.getElementById('log').innerHTML = '';
            log('ğŸ—‘ï¸ æ—¥å¿—å·²æ¸…ç©º', 'info');
        }

        // åˆå§‹åŒ–
        updateStatus();
        updateMapVisualization();
        log('ğŸ¯ Segment Dropå¤æ´»ä¿®å¤æµ‹è¯•ç¯å¢ƒå·²å‡†å¤‡å°±ç»ª', 'success');
        log('ğŸ“ æµ‹è¯•æ­¥éª¤ï¼š', 'info');
        log('1. ç‚¹å‡»"å¼€å§‹æ–°æ¸¸æˆ"ç”Ÿæˆéšœç¢ç‰©', 'info');
        log('2. ç‚¹å‡»"æ¨¡æ‹Ÿæ¸¸æˆç»“æŸ"ç”Ÿæˆsegment drops', 'info');
        log('3. ç‚¹å‡»"æ¨¡æ‹Ÿå¤æ´»"æ¢å¤segment drops', 'info');
        log('4. éªŒè¯segment dropsæ˜¯å¦ä¸éšœç¢ç‰©é‡å ', 'info');
        log('5. æ£€æŸ¥å¤æ´»åsegment dropsæ˜¯å¦å¯è§', 'info');
    </script>
</body>
</html> 
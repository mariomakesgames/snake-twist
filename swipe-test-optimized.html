<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Swipe Test - Optimized (No Duplicate Listeners)</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            font-family: Arial, sans-serif;
            background: #1a1a1a;
            color: white;
        }
        
        .container {
            max-width: 800px;
            margin: 0 auto;
        }
        
        .test-area {
            width: 600px;
            height: 600px;
            border: 2px solid #4CAF50;
            margin: 20px auto;
            position: relative;
            background: #222;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
            color: #ccc;
        }
        
        .info {
            background: #333;
            padding: 15px;
            border-radius: 8px;
            margin: 20px 0;
        }
        
        .log {
            background: #000;
            padding: 15px;
            border-radius: 8px;
            height: 200px;
            overflow-y: auto;
            font-family: monospace;
            font-size: 12px;
            border: 1px solid #444;
        }
        
        .log-entry {
            margin: 2px 0;
            padding: 2px 0;
        }
        
        .log-entry.event {
            color: #4CAF50;
        }
        
        .log-entry.swipe {
            color: #FF9800;
            font-weight: bold;
        }
        
        .log-entry.error {
            color: #f44336;
        }
        
        .controls {
            display: flex;
            gap: 10px;
            margin: 20px 0;
        }
        
        button {
            padding: 10px 20px;
            background: #4CAF50;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
        }
        
        button:hover {
            background: #45a049;
        }
        
        .highlight {
            background: #4CAF50;
            color: white;
            padding: 2px 6px;
            border-radius: 3px;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ðŸŽ® Swipe Test - Optimized Implementation</h1>
        
        <div class="info">
            <h3>âœ… What's Fixed:</h3>
            <ul>
                <li><strong>No Duplicate Listeners:</strong> Removed canvas-specific Phaser input events</li>
                <li><strong>Global Only:</strong> Using only document-level event listeners</li>
                <li><strong>Canvas Bounds Check:</strong> Only starts drag when clicking inside canvas</li>
                <li><strong>Clean State Management:</strong> Proper drag state tracking</li>
            </ul>
        </div>
        
        <div class="test-area" id="testArea">
            <div style="text-align: center;">
                <div style="font-size: 24px; margin-bottom: 10px;">ðŸŽ¯ Test Area</div>
                <div>Click and drag here or anywhere on the page</div>
                <div style="font-size: 14px; margin-top: 10px; color: #888;">
                    Try dragging outside the canvas and releasing!
                </div>
            </div>
        </div>
        
        <div class="controls">
            <button onclick="clearLog()">Clear Log</button>
            <button onclick="toggleLogging()">Toggle Event Logging</button>
            <button onclick="testSwipe()">Test Swipe Detection</button>
        </div>
        
        <div class="log" id="log"></div>
    </div>

    <script>
        let isLogging = true;
        let isDragging = false;
        let touchStartX = 0;
        let touchStartY = 0;
        let touchEndX = 0;
        let touchEndY = 0;
        let touchStartTime = 0;
        let minSwipeDistance = 30;
        let maxSwipeTime = 500;

        function log(message, type = 'info') {
            if (!isLogging) return;
            
            const logElement = document.getElementById('log');
            const entry = document.createElement('div');
            entry.className = `log-entry ${type}`;
            entry.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
            logElement.appendChild(entry);
            logElement.scrollTop = logElement.scrollHeight;
        }

        function clearLog() {
            document.getElementById('log').innerHTML = '';
        }

        function toggleLogging() {
            isLogging = !isLogging;
            log(`Event logging ${isLogging ? 'enabled' : 'disabled'}`, 'info');
        }

        function testSwipe() {
            log('ðŸ§ª Testing swipe detection...', 'info');
            // Simulate a swipe
            handleSwipe('right', 100, 50);
        }

        function handleGlobalMouseDown(event) {
            if (isDragging) return;
            
            const testArea = document.getElementById('testArea');
            const rect = testArea.getBoundingClientRect();
            
            if (event.clientX >= rect.left && event.clientX <= rect.right &&
                event.clientY >= rect.top && event.clientY <= rect.bottom) {
                
                isDragging = true;
                touchStartX = event.clientX - rect.left;
                touchStartY = event.clientY - rect.top;
                touchStartTime = Date.now();
                
                log(`ðŸ–±ï¸ Mouse down inside canvas: (${touchStartX}, ${touchStartY})`, 'event');
            } else {
                log(`ðŸ–±ï¸ Mouse down outside canvas: (${event.clientX}, ${event.clientY})`, 'event');
            }
        }

        function handleGlobalMouseUp(event) {
            if (!isDragging) return;
            
            const testArea = document.getElementById('testArea');
            const rect = testArea.getBoundingClientRect();
            
            touchEndX = event.clientX - rect.left;
            touchEndY = event.clientY - rect.top;
            
            log(`ðŸ–±ï¸ Mouse up: (${touchEndX}, ${touchEndY})`, 'event');
            
            handleSwipe();
            isDragging = false;
        }

        function handleGlobalMouseMove(event) {
            if (!isDragging) return;
            
            const testArea = document.getElementById('testArea');
            const rect = testArea.getBoundingClientRect();
            
            touchEndX = event.clientX - rect.left;
            touchEndY = event.clientY - rect.top;
        }

        function handleGlobalTouchStart(event) {
            if (isDragging) return;
            
            const testArea = document.getElementById('testArea');
            const rect = testArea.getBoundingClientRect();
            const touch = event.touches[0];
            
            if (touch.clientX >= rect.left && touch.clientX <= rect.right &&
                touch.clientY >= rect.top && touch.clientY <= rect.bottom) {
                
                isDragging = true;
                touchStartX = touch.clientX - rect.left;
                touchStartY = touch.clientY - rect.top;
                touchStartTime = Date.now();
                
                log(`ðŸ‘† Touch start inside canvas: (${touchStartX}, ${touchStartY})`, 'event');
            } else {
                log(`ðŸ‘† Touch start outside canvas: (${touch.clientX}, ${touch.clientY})`, 'event');
            }
        }

        function handleGlobalTouchEnd(event) {
            if (!isDragging) return;
            
            const testArea = document.getElementById('testArea');
            const rect = testArea.getBoundingClientRect();
            const touch = event.changedTouches[0];
            
            touchEndX = touch.clientX - rect.left;
            touchEndY = touch.clientY - rect.top;
            
            log(`ðŸ‘† Touch end: (${touchEndX}, ${touchEndY})`, 'event');
            
            handleSwipe();
            isDragging = false;
        }

        function handleGlobalTouchMove(event) {
            if (!isDragging) return;
            
            const testArea = document.getElementById('testArea');
            const rect = testArea.getBoundingClientRect();
            const touch = event.touches[0];
            
            touchEndX = touch.clientX - rect.left;
            touchEndY = touch.clientY - rect.top;
        }

        function handleSwipe(direction = null, deltaX = null, deltaY = null) {
            if (direction) {
                // Simulated swipe for testing
                log(`ðŸŽ¯ SWIPE DETECTED: ${direction.toUpperCase()}`, 'swipe');
                createSwipeEffect(direction, 300, 300);
                return;
            }
            
            const actualDeltaX = touchEndX - touchStartX;
            const actualDeltaY = touchEndY - touchStartY;
            const touchEndTime = Date.now();
            const swipeTime = touchEndTime - touchStartTime;
            
            const distance = Math.sqrt(actualDeltaX * actualDeltaX + actualDeltaY * actualDeltaY);
            
            log(`ðŸ“ Swipe analysis: distance=${distance.toFixed(1)}, time=${swipeTime}ms`, 'info');
            
            if (distance < minSwipeDistance || swipeTime > maxSwipeTime) {
                log(`âŒ Invalid swipe: distance too short or time too long`, 'error');
                return;
            }
            
            const absDeltaX = Math.abs(actualDeltaX);
            const absDeltaY = Math.abs(actualDeltaY);
            
            let detectedDirection = '';
            
            if (absDeltaX > absDeltaY) {
                detectedDirection = actualDeltaX > 0 ? 'right' : 'left';
            } else {
                detectedDirection = actualDeltaY > 0 ? 'down' : 'up';
            }
            
            log(`ðŸŽ¯ SWIPE DETECTED: ${detectedDirection.toUpperCase()}`, 'swipe');
            createSwipeEffect(detectedDirection, touchStartX, touchStartY);
        }

        function createSwipeEffect(direction, x, y) {
            const testArea = document.getElementById('testArea');
            const colors = {
                'up': '#4CAF50',
                'down': '#4CAF50',
                'left': '#4CAF50',
                'right': '#4CAF50'
            };
            
            const color = colors[direction];
            
            // Create visual feedback
            for (let i = 0; i < 5; i++) {
                const particle = document.createElement('div');
                particle.style.position = 'absolute';
                particle.style.width = '6px';
                particle.style.height = '6px';
                particle.style.backgroundColor = color;
                particle.style.borderRadius = '50%';
                particle.style.left = (x + (touchEndX - touchStartX) * (i / 5)) + 'px';
                particle.style.top = (y + (touchEndY - touchStartY) * (i / 5)) + 'px';
                particle.style.pointerEvents = 'none';
                particle.style.transition = 'all 0.3s ease';
                
                testArea.appendChild(particle);
                
                setTimeout(() => {
                    particle.style.opacity = '0';
                    particle.style.transform = 'scale(0)';
                }, i * 50);
                
                setTimeout(() => {
                    testArea.removeChild(particle);
                }, 300 + i * 50);
            }
        }

        // Setup event listeners
        document.addEventListener('mousedown', handleGlobalMouseDown);
        document.addEventListener('mouseup', handleGlobalMouseUp);
        document.addEventListener('mousemove', handleGlobalMouseMove);
        document.addEventListener('touchstart', handleGlobalTouchStart);
        document.addEventListener('touchend', handleGlobalTouchEnd);
        document.addEventListener('touchmove', handleGlobalTouchMove);

        // Initial log
        log('ðŸš€ Optimized swipe detection initialized', 'info');
        log('ðŸ“± Only global event listeners are used (no duplicates)', 'info');
        log('ðŸŽ¯ Try dragging inside or outside the test area!', 'info');
    </script>
</body>
</html> 